# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt6.QtOpenGLWidgets import QOpenGLWidget
import serial.rs485
import PyQt6
from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtCore import QThread, pyqtSignal, QUrl, QObject
from PyQt6.QtWidgets import QMainWindow
import sqlite3
import serial
import serial.tools.list_ports
import time
import struct
import json
import crcmod
import datetime
import pandas as pd
import mplcursors
import sys
from PyQt6.QtWidgets import QApplication, QVBoxLayout, QWidget
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas, NavigationToolbar2QT
import matplotlib
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.dates as mdates
from matplotlib.widgets import Cursor
from statistics import median
from scipy.signal import medfilt
from filterpy.kalman import KalmanFilter

import folium
# Import folium MarkerCluster plugin
from folium.plugins import MarkerCluster
# Import folium MousePosition plugin
from folium.plugins import MousePosition
# Import folium DivIcon plugin
from folium.features import DivIcon

import io

from PyQt6 import QtWebEngineWidgets
from PyQt6.QtWebEngineWidgets import QWebEngineView
from PyQt6.QtCore import QDate, QDateTime, Qt, QTime

import serial.rs485 

from OpenGL.GL import *
from OpenGL.GLU import *
from OpenGL.GLUT import *
from PyQt6.QtOpenGLWidgets  import QOpenGLWidget
import threading

from PyQt6.QtGui import QPainter, QColor, QFont
from PyQt6.QtGui import QSurfaceFormat, QSurfaceFormat
from PyQt6.QtOpenGL import QOpenGLWindow, QOpenGLVersionProfile
from PyQt6.QtCore import QCoreApplication, Qt

import os


QCoreApplication.setAttribute(Qt.ApplicationAttribute.AA_UseOpenGLES)

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1044, 1056)

        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.tabWidget = QtWidgets.QTabWidget(parent=self.centralwidget)
        self.tabWidget.setGeometry(QtCore.QRect(0, 0, 1661, 1111))
        self.tabWidget.setObjectName("tabWidget")
        self.tabComPort = QtWidgets.QWidget()
        self.tabComPort.setObjectName("tabComPort")
        self.label = QtWidgets.QLabel(parent=self.tabComPort)
        self.label.setGeometry(QtCore.QRect(9, 9, 76, 22))
        font = QtGui.QFont()
        font.setPointSize(12)
        self.label.setFont(font)
        self.label.setText("")
        self.label.setObjectName("label")
        self.pushButtonScan = QtWidgets.QPushButton(parent=self.tabComPort)
        self.pushButtonScan.setGeometry(QtCore.QRect(10, 10, 75, 24))
        self.pushButtonScan.setObjectName("pushButtonScan")
        self.pushButtonConnect = QtWidgets.QPushButton(parent=self.tabComPort)
        self.pushButtonConnect.setGeometry(QtCore.QRect(10, 40, 75, 24))
        self.pushButtonConnect.setObjectName("pushButtonConnect")
        self.comboBoxBaudRate = QtWidgets.QComboBox(parent=self.tabComPort)
        self.comboBoxBaudRate.setGeometry(QtCore.QRect(250, 38, 63, 22))
        self.comboBoxBaudRate.setObjectName("comboBoxBaudRate")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.comboBoxBaudRate.addItem("")
        self.label_2 = QtWidgets.QLabel(parent=self.tabComPort)
        self.label_2.setGeometry(QtCore.QRect(250, 9, 53, 16))
        self.label_2.setObjectName("label_2")
        self.comboBox_ComPorts = QtWidgets.QComboBox(parent=self.tabComPort)
        self.comboBox_ComPorts.setGeometry(QtCore.QRect(120, 40, 100, 22))
        self.comboBox_ComPorts.setObjectName("comboBox_ComPorts")
        self.label_COM_Port = QtWidgets.QLabel(parent=self.tabComPort)
        self.label_COM_Port.setGeometry(QtCore.QRect(120, 10, 71, 16))
        self.label_COM_Port.setObjectName("label_COM_Port")
        self.pushButton_CLEAR = QtWidgets.QPushButton(parent=self.tabComPort)
        self.pushButton_CLEAR.setGeometry(QtCore.QRect(880, 660, 75, 24))
        self.pushButton_CLEAR.setObjectName("pushButton_CLEAR")
        self.radioButton_PARSED = QtWidgets.QRadioButton(parent=self.tabComPort)
        self.radioButton_PARSED.setGeometry(QtCore.QRect(790, 10, 89, 20))
        self.radioButton_PARSED.setChecked(True)
        self.radioButton_PARSED.setObjectName("radioButton_PARSED")
        self.plainTextEditComportToSend = QtWidgets.QPlainTextEdit(parent=self.tabComPort)
        self.plainTextEditComportToSend.setGeometry(QtCore.QRect(10, 710, 851, 61))
        self.plainTextEditComportToSend.setObjectName("plainTextEditComportToSend")
        self.pushButton_SEND = QtWidgets.QPushButton(parent=self.tabComPort)
        self.pushButton_SEND.setGeometry(QtCore.QRect(880, 740, 75, 24))
        self.pushButton_SEND.setObjectName("pushButton_SEND")
        self.textBrowserComPort = QtWidgets.QTextBrowser(parent=self.tabComPort)
        self.textBrowserComPort.setGeometry(QtCore.QRect(10, 170, 971, 481))
        self.textBrowserComPort.setObjectName("textBrowserComPort")
        self.layoutWidget = QtWidgets.QWidget(parent=self.tabComPort)
        self.layoutWidget.setGeometry(QtCore.QRect(330, 10, 91, 122))
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.label_Data_Bits = QtWidgets.QLabel(parent=self.layoutWidget)
        self.label_Data_Bits.setObjectName("label_Data_Bits")
        self.verticalLayout.addWidget(self.label_Data_Bits)
        self.radioButton_databits_5 = QtWidgets.QRadioButton(parent=self.layoutWidget)
        self.radioButton_databits_5.setObjectName("radioButton_databits_5")
        self.verticalLayout.addWidget(self.radioButton_databits_5)
        self.radioButton_databits_6 = QtWidgets.QRadioButton(parent=self.layoutWidget)
        self.radioButton_databits_6.setObjectName("radioButton_databits_6")
        self.verticalLayout.addWidget(self.radioButton_databits_6)
        self.radioButton_databits_7 = QtWidgets.QRadioButton(parent=self.layoutWidget)
        self.radioButton_databits_7.setChecked(False)
        self.radioButton_databits_7.setObjectName("radioButton_databits_7")
        self.verticalLayout.addWidget(self.radioButton_databits_7)
        self.radioButton_databits_8 = QtWidgets.QRadioButton(parent=self.layoutWidget)
        self.radioButton_databits_8.setChecked(True)
        self.radioButton_databits_8.setObjectName("radioButton_databits_8")
        self.verticalLayout.addWidget(self.radioButton_databits_8)
        self.layoutWidget1 = QtWidgets.QWidget(parent=self.tabComPort)
        self.layoutWidget1.setGeometry(QtCore.QRect(420, 10, 91, 148))
        self.layoutWidget1.setObjectName("layoutWidget1")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget1)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.label_Parity = QtWidgets.QLabel(parent=self.layoutWidget1)
        self.label_Parity.setObjectName("label_Parity")
        self.verticalLayout_2.addWidget(self.label_Parity)
        self.radioButton_Parity_None = QtWidgets.QRadioButton(parent=self.layoutWidget1)
        self.radioButton_Parity_None.setChecked(True)
        self.radioButton_Parity_None.setObjectName("radioButton_Parity_None")
        self.verticalLayout_2.addWidget(self.radioButton_Parity_None)
        self.radioButton_Parity_Odd = QtWidgets.QRadioButton(parent=self.layoutWidget1)
        self.radioButton_Parity_Odd.setObjectName("radioButton_Parity_Odd")
        self.verticalLayout_2.addWidget(self.radioButton_Parity_Odd)
        self.radioButton_Parity_Even = QtWidgets.QRadioButton(parent=self.layoutWidget1)
        self.radioButton_Parity_Even.setObjectName("radioButton_Parity_Even")
        self.verticalLayout_2.addWidget(self.radioButton_Parity_Even)
        self.radioButton_Parity_Mark = QtWidgets.QRadioButton(parent=self.layoutWidget1)
        self.radioButton_Parity_Mark.setObjectName("radioButton_Parity_Mark")
        self.verticalLayout_2.addWidget(self.radioButton_Parity_Mark)
        self.radioButton_Parity_Space = QtWidgets.QRadioButton(parent=self.layoutWidget1)
        self.radioButton_Parity_Space.setObjectName("radioButton_Parity_Space")
        self.verticalLayout_2.addWidget(self.radioButton_Parity_Space)
        self.layoutWidget2 = QtWidgets.QWidget(parent=self.tabComPort)
        self.layoutWidget2.setGeometry(QtCore.QRect(510, 10, 91, 96))
        self.layoutWidget2.setObjectName("layoutWidget2")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.layoutWidget2)
        self.verticalLayout_3.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.label_StopBits = QtWidgets.QLabel(parent=self.layoutWidget2)
        self.label_StopBits.setObjectName("label_StopBits")
        self.verticalLayout_3.addWidget(self.label_StopBits)
        self.radioButton_StopBits_1 = QtWidgets.QRadioButton(parent=self.layoutWidget2)
        self.radioButton_StopBits_1.setChecked(True)
        self.radioButton_StopBits_1.setObjectName("radioButton_StopBits_1")
        self.verticalLayout_3.addWidget(self.radioButton_StopBits_1)
        self.radioButton_StopBits_15 = QtWidgets.QRadioButton(parent=self.layoutWidget2)
        self.radioButton_StopBits_15.setObjectName("radioButton_StopBits_15")
        self.verticalLayout_3.addWidget(self.radioButton_StopBits_15)
        self.radioButton_StopBits_2 = QtWidgets.QRadioButton(parent=self.layoutWidget2)
        self.radioButton_StopBits_2.setObjectName("radioButton_StopBits_2")
        self.verticalLayout_3.addWidget(self.radioButton_StopBits_2)
        self.layoutWidget3 = QtWidgets.QWidget(parent=self.tabComPort)
        self.layoutWidget3.setGeometry(QtCore.QRect(690, 10, 91, 48))
        self.layoutWidget3.setObjectName("layoutWidget3")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout(self.layoutWidget3)
        self.verticalLayout_4.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.radioButton_ASCII = QtWidgets.QRadioButton(parent=self.layoutWidget3)
        self.radioButton_ASCII.setObjectName("radioButton_ASCII")
        self.verticalLayout_4.addWidget(self.radioButton_ASCII)
        self.radioButton_HEX = QtWidgets.QRadioButton(parent=self.layoutWidget3)
        self.radioButton_HEX.setChecked(True)
        self.radioButton_HEX.setObjectName("radioButton_HEX")
        self.verticalLayout_4.addWidget(self.radioButton_HEX)
        self.tabWidget.addTab(self.tabComPort, "")
        self.Plots = QtWidgets.QWidget()
        self.Plots.setObjectName("Plots")
        self.StartPlotingTemp = QtWidgets.QPushButton(parent=self.Plots)
        self.StartPlotingTemp.setGeometry(QtCore.QRect(10, 60, 81, 31))
        self.StartPlotingTemp.setObjectName("StartPlotingTemp")
        self.StopPlotingTemp = QtWidgets.QPushButton(parent=self.Plots)
        self.StopPlotingTemp.setGeometry(QtCore.QRect(10, 100, 81, 31))
        self.StopPlotingTemp.setObjectName("StopPlotingTemp")
        self.ClearPlotTemp = QtWidgets.QPushButton(parent=self.Plots)
        self.ClearPlotTemp.setGeometry(QtCore.QRect(10, 420, 81, 31))
        self.ClearPlotTemp.setObjectName("ClearPlotTemp")
        self.horizontalSliderTemp = QtWidgets.QSlider(parent=self.Plots)
        self.horizontalSliderTemp.setGeometry(QtCore.QRect(820, 440, 160, 22))
        self.horizontalSliderTemp.setMinimum(2)
        self.horizontalSliderTemp.setProperty("value", 50)
        self.horizontalSliderTemp.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.horizontalSliderTemp.setObjectName("horizontalSliderTemp")
        self.label_6 = QtWidgets.QLabel(parent=self.Plots)
        self.label_6.setGeometry(QtCore.QRect(410, 10, 201, 41))
        font = QtGui.QFont()
        font.setPointSize(18)
        self.label_6.setFont(font)
        self.label_6.setObjectName("label_6")
        self.comboBox_Filters_temp = QtWidgets.QComboBox(parent=self.Plots)
        self.comboBox_Filters_temp.setGeometry(QtCore.QRect(10, 240, 81, 31))
        self.comboBox_Filters_temp.setObjectName("comboBox_Filters_temp")
        self.comboBox_Filters_temp.addItem("")
        self.comboBox_Filters_temp.addItem("")
        self.comboBox_Filters_temp.addItem("")
        self.comboBox_Filters_temp.addItem("")
        self.splitter = QtWidgets.QSplitter(parent=self.Plots)
        self.splitter.setGeometry(QtCore.QRect(830, 50, 151, 201))
        self.splitter.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.splitter.setObjectName("splitter")
        self.label_3 = QtWidgets.QLabel(parent=self.splitter)
        self.label_3.setObjectName("label_3")
        self.lcdNumberTempCPU = QtWidgets.QLCDNumber(parent=self.splitter)
        self.lcdNumberTempCPU.setObjectName("lcdNumberTempCPU")
        self.label_4 = QtWidgets.QLabel(parent=self.splitter)
        self.label_4.setObjectName("label_4")
        self.lcdNumberInternalTemp = QtWidgets.QLCDNumber(parent=self.splitter)
        self.lcdNumberInternalTemp.setObjectName("lcdNumberInternalTemp")
        self.label_5 = QtWidgets.QLabel(parent=self.splitter)
        self.label_5.setObjectName("label_5")
        self.lcdNumberExtrenalTemp = QtWidgets.QLCDNumber(parent=self.splitter)
        self.lcdNumberExtrenalTemp.setSmallDecimalPoint(False)
        self.lcdNumberExtrenalTemp.setObjectName("lcdNumberExtrenalTemp")
        self.layoutWidget4 = QtWidgets.QWidget(parent=self.Plots)
        self.layoutWidget4.setGeometry(QtCore.QRect(10, 150, 78, 74))
        self.layoutWidget4.setObjectName("layoutWidget4")
        self.verticalLayout_5 = QtWidgets.QVBoxLayout(self.layoutWidget4)
        self.verticalLayout_5.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.checkBoxCPUTemp = QtWidgets.QCheckBox(parent=self.layoutWidget4)
        self.checkBoxCPUTemp.setChecked(True)
        self.checkBoxCPUTemp.setObjectName("checkBoxCPUTemp")
        self.verticalLayout_5.addWidget(self.checkBoxCPUTemp)
        self.checkBox_InternalTemp = QtWidgets.QCheckBox(parent=self.layoutWidget4)
        self.checkBox_InternalTemp.setChecked(True)
        self.checkBox_InternalTemp.setObjectName("checkBox_InternalTemp")
        self.verticalLayout_5.addWidget(self.checkBox_InternalTemp)
        self.checkBox_ExternalTemp = QtWidgets.QCheckBox(parent=self.layoutWidget4)
        self.checkBox_ExternalTemp.setChecked(True)
        self.checkBox_ExternalTemp.setObjectName("checkBox_ExternalTemp")
        self.verticalLayout_5.addWidget(self.checkBox_ExternalTemp)
        self.widgetTempPlot = QtWidgets.QWidget(parent=self.Plots)
        self.widgetTempPlot.setGeometry(QtCore.QRect(120, 60, 691, 441))
        self.widgetTempPlot.setObjectName("widgetTempPlot")
        self.horizontalSliderTempLabel = QtWidgets.QLabel(parent=self.Plots)
        self.horizontalSliderTempLabel.setGeometry(QtCore.QRect(860, 470, 111, 20))
        self.horizontalSliderTempLabel.setObjectName("horizontalSliderTempLabel")
        self.widgetAltitudePlot = QtWidgets.QWidget(parent=self.Plots)
        self.widgetAltitudePlot.setGeometry(QtCore.QRect(120, 540, 701, 441))
        self.widgetAltitudePlot.setObjectName("widgetAltitudePlot")
        self.ClearAltitudePlot = QtWidgets.QPushButton(parent=self.Plots)
        self.ClearAltitudePlot.setGeometry(QtCore.QRect(10, 900, 81, 31))
        self.ClearAltitudePlot.setObjectName("ClearAltitudePlot")
        self.checkBox_Altitude = QtWidgets.QCheckBox(parent=self.Plots)
        self.checkBox_Altitude.setGeometry(QtCore.QRect(10, 690, 76, 20))
        self.checkBox_Altitude.setChecked(True)
        self.checkBox_Altitude.setObjectName("checkBox_Altitude")
        self.StartAltitudePlot = QtWidgets.QPushButton(parent=self.Plots)
        self.StartAltitudePlot.setGeometry(QtCore.QRect(10, 590, 81, 31))
        self.StartAltitudePlot.setObjectName("StartAltitudePlot")
        self.comboBox_Filters_Altitude = QtWidgets.QComboBox(parent=self.Plots)
        self.comboBox_Filters_Altitude.setGeometry(QtCore.QRect(10, 770, 81, 31))
        self.comboBox_Filters_Altitude.setObjectName("comboBox_Filters_Altitude")
        self.comboBox_Filters_Altitude.addItem("")
        self.comboBox_Filters_Altitude.addItem("")
        self.comboBox_Filters_Altitude.addItem("")
        self.comboBox_Filters_Altitude.addItem("")
        self.StopAltitudePlot = QtWidgets.QPushButton(parent=self.Plots)
        self.StopAltitudePlot.setGeometry(QtCore.QRect(10, 630, 81, 31))
        self.StopAltitudePlot.setObjectName("StopAltitudePlot")
        self.horizontalSliderAltitudePlot = QtWidgets.QSlider(parent=self.Plots)
        self.horizontalSliderAltitudePlot.setGeometry(QtCore.QRect(840, 890, 160, 22))
        self.horizontalSliderAltitudePlot.setMinimum(2)
        self.horizontalSliderAltitudePlot.setProperty("value", 50)
        self.horizontalSliderAltitudePlot.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.horizontalSliderAltitudePlot.setObjectName("horizontalSliderAltitudePlot")
        self.horizontalSliderAltitudeLabel = QtWidgets.QLabel(parent=self.Plots)
        self.horizontalSliderAltitudeLabel.setGeometry(QtCore.QRect(880, 920, 111, 20))
        self.horizontalSliderAltitudeLabel.setObjectName("horizontalSliderAltitudeLabel")
        self.lcdNumberAltitude = QtWidgets.QLCDNumber(parent=self.Plots)
        self.lcdNumberAltitude.setGeometry(QtCore.QRect(840, 590, 151, 35))
        self.lcdNumberAltitude.setObjectName("lcdNumberAltitude")
        self.label_25 = QtWidgets.QLabel(parent=self.Plots)
        self.label_25.setGeometry(QtCore.QRect(840, 561, 151, 24))
        self.label_25.setObjectName("label_25")
        self.tabWidget.addTab(self.Plots, "")
        self.PlotsDB = QtWidgets.QWidget()
        self.PlotsDB.setObjectName("PlotsDB")
        self.DisplayDBPlot = QtWidgets.QPushButton(parent=self.PlotsDB)
        self.DisplayDBPlot.setGeometry(QtCore.QRect(20, 40, 75, 24))
        self.DisplayDBPlot.setObjectName("DisplayDBPlot")
        self.DBTempPLot = QtWidgets.QWidget(parent=self.PlotsDB)
        self.DBTempPLot.setGeometry(QtCore.QRect(150, 30, 851, 461))
        self.DBTempPLot.setObjectName("DBTempPLot")
        self.dateEditDBFfrom = QtWidgets.QDateEdit(parent=self.PlotsDB)
        self.dateEditDBFfrom.setGeometry(QtCore.QRect(20, 200, 110, 22))
        self.dateEditDBFfrom.setObjectName("dateEditDBFfrom")
        self.dateEditDBFto = QtWidgets.QDateEdit(parent=self.PlotsDB)
        self.dateEditDBFto.setGeometry(QtCore.QRect(20, 250, 110, 22))
        self.dateEditDBFto.setObjectName("dateEditDBFto")
        self.label_7 = QtWidgets.QLabel(parent=self.PlotsDB)
        self.label_7.setGeometry(QtCore.QRect(20, 180, 49, 16))
        self.label_7.setObjectName("label_7")
        self.label_8 = QtWidgets.QLabel(parent=self.PlotsDB)
        self.label_8.setGeometry(QtCore.QRect(20, 230, 49, 16))
        self.label_8.setObjectName("label_8")
        self.widget = QtWidgets.QWidget(parent=self.PlotsDB)
        self.widget.setGeometry(QtCore.QRect(20, 80, 109, 74))
        self.widget.setObjectName("widget")
        self.verticalLayout_6 = QtWidgets.QVBoxLayout(self.widget)
        self.verticalLayout_6.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.dbCPUtemp = QtWidgets.QCheckBox(parent=self.widget)
        self.dbCPUtemp.setObjectName("dbCPUtemp")
        self.verticalLayout_6.addWidget(self.dbCPUtemp)
        self.dbExternaltemp = QtWidgets.QCheckBox(parent=self.widget)
        self.dbExternaltemp.setObjectName("dbExternaltemp")
        self.verticalLayout_6.addWidget(self.dbExternaltemp)
        self.dbInternaltemp = QtWidgets.QCheckBox(parent=self.widget)
        self.dbInternaltemp.setObjectName("dbInternaltemp")
        self.verticalLayout_6.addWidget(self.dbInternaltemp)

        self.dbInternaltemp.setChecked(True)
        self.dbExternaltemp.setChecked(True)
        self.dbCPUtemp.setChecked(True)

        self.tabWidget.addTab(self.PlotsDB, "")
        self.GPSMap = QtWidgets.QWidget()
        self.GPSMap.setObjectName("GPSMap")
        self.widgetMap = QtWidgets.QWidget(parent=self.GPSMap)
        self.widgetMap.setGeometry(QtCore.QRect(10, 20, 1011, 831))
        self.widgetMap.setObjectName("widgetMap")
        self.tabWidget.addTab(self.GPSMap, "")
       
        self.tabIMU = QtWidgets.QWidget()
        self.tabIMU.setObjectName("tabIMU")
        
        self.openGLWidget_IMU = OpenGLWidget_IMU(self.tabIMU)
        
        self.openGLWidget_IMU.setGeometry(QtCore.QRect(170, 10, 611, 501))
        self.openGLWidget_IMU.setObjectName("openGLWidget_IMU")
        
        self.pushButtonScan_IMU = QtWidgets.QPushButton(self.tabIMU)
        self.pushButtonScan_IMU.setGeometry(QtCore.QRect(10, 20, 75, 24))
        self.pushButtonScan_IMU.setObjectName("pushButtonScan_IMU")
        self.pushButtonConnect_IMU = QtWidgets.QPushButton(self.tabIMU)
        self.pushButtonConnect_IMU.setGeometry(QtCore.QRect(10, 50, 75, 24))
        self.pushButtonConnect_IMU.setObjectName("pushButtonConnect_IMU")
        self.comboBox_ComPorts_IMU = QtWidgets.QComboBox(self.tabIMU)
        self.comboBox_ComPorts_IMU.setGeometry(QtCore.QRect(10, 110, 100, 22))
        self.comboBox_ComPorts_IMU.setObjectName("comboBox_ComPorts_IMU")
        
        self.radioButton_IMU_Filter = QtWidgets.QRadioButton(self.tabIMU)
        self.radioButton_IMU_Filter.setObjectName(u"radioButton_IMU_Filter")
        self.radioButton_IMU_Filter.setGeometry(QtCore.QRect(10, 160, 100, 30))


        self.tabWidget.addTab(self.tabIMU, "IMU")
        



        self.serial_port = None
        self.kf_roll = KalmanFilter2(0.1, 0.01, 0.1)
        self.kf_pitch = KalmanFilter2(0.1, 0.01, 0.1)
        self.kf_yaw = KalmanFilter2(0.1, 0.01, 0.1)






        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(4)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
	
        self.add_functions()
        self.creatTempRealTimePlot()
        self.creatAltitudeRealTimePlot()
        self.creatTempDBPlot()
        self.drawMap()

        self.kalman_filter_external_temp = KalmanFilter(dim_x=1, dim_z=1)
        self.kalman_filter_external_temp.x = np.array([0.0])  # Initial state
        self.kalman_filter_external_temp.F = np.array([[1]])  # State transition matrix
        self.kalman_filter_external_temp.H = np.array([[1]])  # Measurement function matrix
        self.kalman_filter_external_temp.P *= 1e2  # Initial state covariance

        self.kalman_filter_internal_temp = KalmanFilter(dim_x=1, dim_z=1)
        self.kalman_filter_internal_temp.x = np.array([0.0])  # Initial state
        self.kalman_filter_internal_temp.F = np.array([[1]])  # State transition matrix
        self.kalman_filter_internal_temp.H = np.array([[1]])  # Measurement function matrix
        self.kalman_filter_internal_temp.P *= 1e2  # Initial state covariance

        self.kalman_filter_CPU_temp = KalmanFilter(dim_x=1, dim_z=1)
        self.kalman_filter_CPU_temp.x = np.array([0.0])  # Initial state
        self.kalman_filter_CPU_temp.F = np.array([[1]])  # State transition matrix
        self.kalman_filter_CPU_temp.H = np.array([[1]])  # Measurement function matrix
        self.kalman_filter_CPU_temp.P *= 1e2  # Initial state covariance

        self.kalman_filter_altitude = KalmanFilter(dim_x=1, dim_z=1)
        self.kalman_filter_altitude.x = np.array([0.0])  # Initial state
        self.kalman_filter_altitude.F = np.array([[1]])  # State transition matrix
        self.kalman_filter_altitude.H = np.array([[1]])  # Measurement function matrix
        self.kalman_filter_altitude.P *= 1e2  # Initial state covariance

        self.serial_reading_active = False


    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "MainWindow"))
        self.pushButtonScan.setText(_translate("MainWindow", "Scan"))
        self.pushButtonConnect.setText(_translate("MainWindow", "Connect"))
        self.comboBoxBaudRate.setItemText(0, _translate("MainWindow", "9600"))
        self.comboBoxBaudRate.setItemText(1, _translate("MainWindow", "600"))
        self.comboBoxBaudRate.setItemText(2, _translate("MainWindow", "1200"))
        self.comboBoxBaudRate.setItemText(3, _translate("MainWindow", "2400"))
        self.comboBoxBaudRate.setItemText(4, _translate("MainWindow", "4800"))
        self.comboBoxBaudRate.setItemText(5, _translate("MainWindow", "14400"))
        self.comboBoxBaudRate.setItemText(6, _translate("MainWindow", "19200"))
        self.comboBoxBaudRate.setItemText(7, _translate("MainWindow", "28800"))
        self.comboBoxBaudRate.setItemText(8, _translate("MainWindow", "38400"))
        self.comboBoxBaudRate.setItemText(9, _translate("MainWindow", "56000"))
        self.comboBoxBaudRate.setItemText(10, _translate("MainWindow", "57600"))
        self.comboBoxBaudRate.setItemText(11, _translate("MainWindow", "115200"))
        self.comboBoxBaudRate.setItemText(12, _translate("MainWindow", "128000"))
        self.comboBoxBaudRate.setItemText(13, _translate("MainWindow", "256000"))
        self.label_2.setText(_translate("MainWindow", "Baud Rate"))
        self.label_COM_Port.setText(_translate("MainWindow", "COM Port"))
        self.pushButton_CLEAR.setText(_translate("MainWindow", "CLEAR"))
        self.radioButton_PARSED.setText(_translate("MainWindow", "PARSED"))
        self.pushButton_SEND.setText(_translate("MainWindow", "Send"))
        self.label_Data_Bits.setText(_translate("MainWindow", "Data Bits"))
        self.radioButton_databits_5.setText(_translate("MainWindow", "5"))
        self.radioButton_databits_6.setText(_translate("MainWindow", "6"))
        self.radioButton_databits_7.setText(_translate("MainWindow", "7"))
        self.radioButton_databits_8.setText(_translate("MainWindow", "8"))
        self.label_Parity.setText(_translate("MainWindow", "Parity"))
        self.radioButton_Parity_None.setText(_translate("MainWindow", "none"))
        self.radioButton_Parity_Odd.setText(_translate("MainWindow", "odd"))
        self.radioButton_Parity_Even.setText(_translate("MainWindow", "even"))
        self.radioButton_Parity_Mark.setText(_translate("MainWindow", "mark"))
        self.radioButton_Parity_Space.setText(_translate("MainWindow", "space"))
        self.label_StopBits.setText(_translate("MainWindow", "Stop Bits"))
        self.radioButton_StopBits_1.setText(_translate("MainWindow", "1"))
        self.radioButton_StopBits_15.setText(_translate("MainWindow", "1.5"))
        self.radioButton_StopBits_2.setText(_translate("MainWindow", "2"))
        self.radioButton_ASCII.setText(_translate("MainWindow", "ASCII"))
        self.radioButton_HEX.setText(_translate("MainWindow", "HEX"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tabComPort), _translate("MainWindow", "COM Port Terminal"))
        self.StartPlotingTemp.setText(_translate("MainWindow", "Start"))
        self.StopPlotingTemp.setText(_translate("MainWindow", "Stop"))
        self.ClearPlotTemp.setText(_translate("MainWindow", "Clear"))
        self.label_6.setText(_translate("MainWindow", "Temperature Plot"))
        self.comboBox_Filters_temp.setItemText(0, _translate("MainWindow", "No-Filter"))
        self.comboBox_Filters_temp.setItemText(1, _translate("MainWindow", "Kalman"))
        self.comboBox_Filters_temp.setItemText(2, _translate("MainWindow", "exp. mov_aver"))
        self.comboBox_Filters_temp.setItemText(3, _translate("MainWindow", "median"))
        self.label_3.setText(_translate("MainWindow", "Temperature CPU"))
        self.label_4.setText(_translate("MainWindow", "Temperature Internal"))
        self.label_5.setText(_translate("MainWindow", "Temperature External"))
        self.checkBoxCPUTemp.setText(_translate("MainWindow", "CPU"))
        self.checkBox_InternalTemp.setText(_translate("MainWindow", "Internal"))
        self.checkBox_ExternalTemp.setText(_translate("MainWindow", "External"))
        self.horizontalSliderTempLabel.setText(_translate("MainWindow", "TextLabel"))
        self.ClearAltitudePlot.setText(_translate("MainWindow", "Clear"))
        self.checkBox_Altitude.setText(_translate("MainWindow", "Altitude"))
        self.StartAltitudePlot.setText(_translate("MainWindow", "Start"))
        self.comboBox_Filters_Altitude.setItemText(0, _translate("MainWindow", "No-Filter"))
        self.comboBox_Filters_Altitude.setItemText(1, _translate("MainWindow", "Kalman"))
        self.comboBox_Filters_Altitude.setItemText(2, _translate("MainWindow", "exp. mov_aver"))
        self.comboBox_Filters_Altitude.setItemText(3, _translate("MainWindow", "median"))
        self.StopAltitudePlot.setText(_translate("MainWindow", "Stop"))
        self.horizontalSliderAltitudeLabel.setText(_translate("MainWindow", "TextLabel"))
        self.label_25.setText(_translate("MainWindow", "Altitude"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Plots), _translate("MainWindow", "Plots"))
        self.DisplayDBPlot.setText(_translate("MainWindow", "Display"))
        self.label_7.setText(_translate("MainWindow", "From"))
        self.label_8.setText(_translate("MainWindow", "To"))
        self.dbCPUtemp.setText(_translate("MainWindow", "CPU"))
        self.dbExternaltemp.setText(_translate("MainWindow", "External"))
        self.dbInternaltemp.setText(_translate("MainWindow", "Internal"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.PlotsDB), _translate("MainWindow", "PlotsDB"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.GPSMap), _translate("MainWindow", "GPSMap"))
        
        self.pushButtonScan_IMU.setText(_translate("MainWindow", "Scan"))
        self.pushButtonConnect_IMU.setText(_translate("MainWindow", "Connect"))
        
        self.radioButton_IMU_Filter.setText(QCoreApplication.translate("MainWindow", u"Filter", None))
        
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tabIMU), _translate("MainWindow", "IMU"))

    def add_functions(self):
        self.pushButtonConnect.clicked.connect(self.connect_to_serial_port)
        self.pushButtonScan.clicked.connect(self.scan_com_ports)
        self.pushButton_SEND.clicked.connect(self.send_text_via_com_port)
        self.pushButton_CLEAR.clicked.connect(self.clear_text_browser)

        self.ClearPlotTemp.clicked.connect(self.clearPlotTemp)
        self.StartPlotingTemp.clicked.connect(self.startPlottingTemp)
        self.StopPlotingTemp.clicked.connect(self.stopPlottingTemp)
        self.horizontalSliderTemp.valueChanged.connect(self.sliderValueChangedTemp)

        self.ClearAltitudePlot.clicked.connect(self.clearPlotAltitude)
        self.StartAltitudePlot.clicked.connect(self.startPlottingAltitude)
        self.StopAltitudePlot.clicked.connect(self.stopPlottingAltitude)
        self.horizontalSliderAltitudePlot.valueChanged.connect(self.sliderValueChangedAltitude)

        self.DisplayDBPlot.clicked.connect(self.updateDbPlot)
        
        self.pushButtonConnect_IMU.clicked.connect(self.connect_to_port)
        self.pushButtonScan_IMU.clicked.connect(self.scan_ports)

        # Connect tab change signal
        self.tabWidget.currentChanged.connect(self.on_tab_change)

    def on_tab_change(self, index):
        if index == self.tabWidget.indexOf(self.tabIMU):
            if not self.serial_reading_active:
                self.serial_reading_active = True
                self.start_serial_reading("COM_PORT")  # Replace "COM_PORT" with the actual port
        else:
            if self.serial_reading_active:
                self.serial_reading_active = False
                # Implement a method to stop serial reading if necessary
                self.stop_serial_reading()


    def scan_ports(self):
        ports = [port.device for port in serial.tools.list_ports.comports()]
        self.comboBox_ComPorts_IMU.clear()
        self.comboBox_ComPorts_IMU.addItems(ports)

    def connect_to_port(self):
        port = self.comboBox_ComPorts_IMU.currentText()
        if port:
            self.serial_port = port  # Save port for later use
            self.start_serial_reading(port)  # Start reading from the port
            print(port)

    def on_tab_change(self, index):
        if index == self.tabWidget.indexOf(self.tabIMU):
            if not self.serial_reading_active:                
                self.serial_reading_active = True
                self.start_serial_reading(self.serial_port)  # Replace "COM_PORT" with the actual port
        else:
            if self.serial_reading_active:
                self.serial_reading_active = False
                self.stop_serial_reading()

    def start_serial_reading(self, port):
        baudrate = 115200

        def read_from_com_port():
            self.ser = serial.Serial(port, baudrate, timeout=1)
            dt = 0.1
            process_noise = 0.01
            measurement_noise = 0.1

            roll_kf = KalmanFilter2(dt, process_noise, measurement_noise)
            pitch_kf = KalmanFilter2(dt, process_noise, measurement_noise)
            yaw_kf = KalmanFilter2(dt, process_noise, measurement_noise)

            while self.serial_reading_active:
                if self.ser.in_waiting > 0:
                    data = self.ser.readline().decode('utf-8', errors='replace').strip()
                    if "Acceleration" in data or "Gyroscope" in data:
                        parsed_data = parse_sensor_data(data)
                        if parsed_data:
                            ax, ay, az = parsed_data["Acceleration"]
                            gx, gy, gz = parsed_data["Gyroscope"]

                            if not self.radioButton_IMU_Filter.isChecked():
                                noise_level = 0.1
                                ax += np.random.normal(0, noise_level)
                                ay += np.random.normal(0, noise_level)
                                az += np.random.normal(0, noise_level)
                                gx += np.random.normal(0, noise_level)
                                gy += np.random.normal(0, noise_level)
                                gz += np.random.normal(0, noise_level)

                            roll_acc = np.arctan2(ay, az) * 180 / np.pi
                            pitch_acc = np.arctan2(-ax, np.sqrt(ay ** 2 + az ** 2)) * 180 / np.pi
                            yaw_acc = 0

                            gx, gy = np.radians([gx, gy])

                            roll_kf.predict(gx)
                            roll_kf.update(roll_acc)
                            pitch_kf.predict(gy)
                            pitch_kf.update(pitch_acc)
                            yaw_kf.predict(gz)
                            yaw_kf.update(yaw_acc)

                            roll = roll_kf.get_angle()
                            pitch = pitch_kf.get_angle()
                            yaw = yaw_kf.get_angle()

                            self.openGLWidget_IMU.update_data(roll, pitch, yaw)

            if self.ser:
                self.ser.close()

        self.serial_thread = threading.Thread(target=read_from_com_port, daemon=True)
        self.serial_thread.start()


    def stop_serial_reading(self):
        self.serial_reading_active = False
        if self.serial_thread:
            self.serial_thread.join()  # Wait for the thread to finish
            self.serial_thread = None
        if self.ser:
            self.ser.close()
            self.ser = None



    def scan_com_ports(self):
        self.disconnect_from_serial_port()
        # self.textBrowserComPort.append('disconnect from serial port')

        # Clear the comboBox before adding new items
        self.comboBox_ComPorts.clear()

        # Get a list of all available COM ports
        ports = serial.tools.list_ports.comports()

        # Populate the comboBox with the available COM ports
        for port_info in ports:
            port, desc, hwid = port_info
            # Add the COM port to the comboBox. You could also include desc or hwid if needed.
            self.comboBox_ComPorts.addItem(f"{port}", port_info)
        
        # Optionally, you can print the list to the console or handle an empty list scenario
        if ports:
            print("COM ports have been updated.")
        else:
            print("No COM ports found.")
    
    def disconnect_from_serial_port(self):
        # Check if the serial_thread exists and is running before attempting to stop it
        if hasattr(self, 'serial_thread') and self.serial_thread and self.serial_thread.isRunning():
            self.serial_thread.terminate()  # or self.serial_thread.quit() based on your implementation
            self.serial_thread.wait()  # Wait for the thread to safely finish

        # Close the serial connection if it's open
        if hasattr(self, 'serial_connection') and self.serial_connection and self.serial_connection.is_open:
            self.serial_connection.close()
            print("Disconnected from the serial port.")

    def send_text_via_com_port(self):
        # Check if the serial connection is open
        if hasattr(self, 'serial_connection') and self.serial_connection.is_open:
            # Read text from the QPlainTextEdit widget
            text_to_send = self.plainTextEditComportToSend.toPlainText()

            # Send the text through the serial port
            try:
                self.serial_connection.write(text_to_send.encode('utf-8'))
                print("Sent:", text_to_send)
                # Optionally clear the text edit after sending
                self.plainTextEditComportToSend.clear()
            except Exception as e:
                print("Error sending text:", e)
        else:
            print("Serial connection not open.")

    def get_data_bits(self):
        data_bits_options = {
            self.radioButton_databits_5: 5,
            self.radioButton_databits_6: 6,
            self.radioButton_databits_7: 7,
            self.radioButton_databits_8: 8
        }
        return next((bits for rb, bits in data_bits_options.items() if rb.isChecked()), 7)  # Default to 7

    def get_parity(self):
        parity_options = {
            self.radioButton_Parity_None: serial.PARITY_NONE,
            self.radioButton_Parity_Odd: serial.PARITY_ODD,
            self.radioButton_Parity_Even: serial.PARITY_EVEN,
            self.radioButton_Parity_Mark: serial.PARITY_MARK,
            self.radioButton_Parity_Space: serial.PARITY_SPACE
        }
        return next((p for rb, p in parity_options.items() if rb.isChecked()), serial.PARITY_NONE)  # Default to 'None'

    def get_stop_bits(self):
        stop_bits_options = {
            self.radioButton_StopBits_1: serial.STOPBITS_ONE,
            self.radioButton_StopBits_15: serial.STOPBITS_ONE_POINT_FIVE,
            self.radioButton_StopBits_2: serial.STOPBITS_TWO
        }
        return next((sb for rb, sb in stop_bits_options.items() if rb.isChecked()), serial.STOPBITS_ONE)  # Default to 1

    def clearPlotTemp(self):
        externalTemperatureArray.clear()
        internalTemperatureArray.clear()
        CPUTemperatureArray.clear()
        self.axes.clear()
        self.canvas.draw()

    def startPlottingTemp(self):
        self.plotting_enabled = True

    def stopPlottingTemp(self):
        self.plotting_enabled = False

    def sliderValueChangedTemp(self):
        global externalTemperatureArray, internalTemperatureArray, CPUTemperatureArray
        value = self.horizontalSliderTemp.value()
        self.horizontalSliderTempLabel.setText(str(value))
         # Clear the plot if the slider value is reduced
        if value < len(externalTemperatureArray):
            elements_to_remove = len(externalTemperatureArray) - value
            externalTemperatureArray = externalTemperatureArray[elements_to_remove:]
        if value < len(internalTemperatureArray):
            elements_to_remove = len(internalTemperatureArray) - value
            internalTemperatureArray = externalTemperatureArray[elements_to_remove:]
        if value < len(CPUTemperatureArray):
            elements_to_remove = len(CPUTemperatureArray) - value
            CPUTemperatureArray = CPUTemperatureArray[elements_to_remove:]
        return value
    
    def creatTempRealTimePlot(self):
        # Create a Matplotlib figure
        self.figure = Figure()

        # Create a Matplotlib canvas
        self.canvas = FigureCanvas(self.figure)
        self.axes = self.figure.add_subplot(111)

            # Format the X-axis labels as time
        self.axes.xaxis_date()
        self.axes.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))

        # Rotate the X-axis labels for better readability
        self.figure.autofmt_xdate()

        # self.lines = self.axes.plot([], [])[0]

        # Create a layout and add the Matplotlib canvas to it
        layout = QVBoxLayout(self.widgetTempPlot)
        layout.addWidget(self.canvas)
        layout.addWidget(NavigationToolbar2QT(self.canvas, self.widgetTempPlot))
        # Update the canvas
        self.canvas.draw()

        self.plotting_enabled = True

    def renderPlot(self, data):
        if not self.plotting_enabled:
            return
    
        # Assuming parse_packet is defined somewhere
        packet4Plot = parse_packet(data)

        # Update global_data_array with new data
        current_time = datetime.datetime.now()

        externalTemp = '{:.2f}'.format(packet4Plot['temp_external'] / 100)
        internalTemp = '{:.2f}'.format(packet4Plot['temp_hdc'] / 100)
        CPUTemp = '{:.2f}'.format(packet4Plot['temp_mc'] / 100)

        # Apply Kalman filter
        self.kalman_filter_external_temp.predict()
        self.kalman_filter_external_temp.update( float(externalTemp))
         # Get the filtered temperature
        filtered_external_temperature_kalman = self.kalman_filter_external_temp.x[0]

        # Apply Kalman filter
        self.kalman_filter_internal_temp.predict()
        self.kalman_filter_internal_temp.update( float(internalTemp))
         # Get the filtered temperature
        filtered_internal_temperature_kalman = self.kalman_filter_internal_temp.x[0]
        
        # Apply Kalman filter
        self.kalman_filter_CPU_temp.predict()
        self.kalman_filter_CPU_temp.update( float(CPUTemp))
         # Get the filtered temperature
        filtered_CPU_temperature_kalman = self.kalman_filter_CPU_temp.x[0]
        
        
        self.ema_alpha = 0.5  # EMA smoothing factor
        self.ema_value = 0.3  # Initial EMA value
        filtered_external_temperature_expmove_avr = self.ema_alpha * float(externalTemp) + (1 - self.ema_alpha) * self.ema_value
        filtered_internal_temperature_expmove_avr = self.ema_alpha * float(internalTemp) + (1 - self.ema_alpha) * self.ema_value
        filtered_CPU_temperature_expmove_avr = self.ema_alpha * float(CPUTemp) + (1 - self.ema_alpha) * self.ema_value

        self.ema_alpha1 = 1  # EMA smoothing factor 
        filtered_external_temperature_median = self.ema_alpha1 * float(externalTemp) + (1 - self.ema_alpha1) * self.ema_value
        filtered_internal_temperature_median = self.ema_alpha1 * float(internalTemp) + (1 - self.ema_alpha1) * self.ema_value
        filtered_CPU_temperature_median = self.ema_alpha1 * float(CPUTemp) + (1 - self.ema_alpha1) * self.ema_value
        # Clear the existing plot
        self.axes.clear()

        # Get the limit from the slider
        limit = self.sliderValueChangedTemp()

        selected_filter = self.comboBox_Filters_temp.currentText()

        if selected_filter is None:
            selected_filter = "No-Filter"

        # Plot the data from externalTemperatureArray
        if len(externalTemperatureArray) < limit:
            x = mdates.date2num(current_time)
            y = 0
            if selected_filter == "No-Filter":
                y = float(externalTemp)  # Convert y to float
            elif selected_filter == "Kalman":
                y = float(filtered_external_temperature_kalman)
            elif selected_filter == "exp. mov_aver":
                y = float(filtered_external_temperature_expmove_avr)
            elif selected_filter == "median":
                y = float(filtered_external_temperature_median)
            externalTemperatureArray.append((x, y))
        else:
            externalTemperatureArray[0:limit-1 ] = externalTemperatureArray[1:limit]
            if selected_filter == "No-Filter":
                externalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(externalTemp))
            elif selected_filter == "Kalman":
                externalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_external_temperature_kalman))
            elif selected_filter == "exp. mov_aver":
                externalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_external_temperature_expmove_avr))
            elif selected_filter == "median":
                externalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_external_temperature_median))
                
          # Plot the data from internalTemperatureArray
        if len(internalTemperatureArray) < limit:
            x = mdates.date2num(current_time)
            y = 0
            if selected_filter == "No-Filter":
                y = float(internalTemp)  # Convert y to float
            elif selected_filter == "Kalman":
                y = float(filtered_internal_temperature_kalman)
            elif selected_filter == "exp. mov_aver":
                y = float(filtered_internal_temperature_expmove_avr)
            elif selected_filter == "median":
                y = float(filtered_internal_temperature_median)
            internalTemperatureArray.append((x, y))
        else:
            internalTemperatureArray[0:limit-1 ] = internalTemperatureArray[1:limit]
            if selected_filter == "No-Filter":
                internalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(internalTemp))
            elif selected_filter == "Kalman":
                internalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_internal_temperature_kalman))
            elif selected_filter == "exp. mov_aver":
                internalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_internal_temperature_expmove_avr))
            elif selected_filter == "median":
                internalTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_internal_temperature_median))

        # Plot the data from CPUTemperatureArray
        if len(CPUTemperatureArray) < limit:
            x = mdates.date2num(current_time)
            y = 0
            if selected_filter == "No-Filter":
                y = float(CPUTemp)  # Convert y to float
            elif selected_filter == "Kalman":
                y = float(filtered_CPU_temperature_kalman)
            elif selected_filter == "exp. mov_aver":
                y = float(filtered_CPU_temperature_expmove_avr)
            elif selected_filter == "median":
                y = float(filtered_CPU_temperature_median)
            CPUTemperatureArray.append((x, y))
        else:
            CPUTemperatureArray[0:limit-1 ] = CPUTemperatureArray[1:limit]
            if selected_filter == "No-Filter":
                CPUTemperatureArray[limit-1] = (mdates.date2num(current_time), float(CPUTemp))
            elif selected_filter == "Kalman":
                CPUTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_CPU_temperature_kalman))
            elif selected_filter == "exp. mov_aver":
                CPUTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_CPU_temperature_expmove_avr))
            elif selected_filter == "median":
                CPUTemperatureArray[limit-1] = (mdates.date2num(current_time), float(filtered_CPU_temperature_median))

        if self.checkBoxCPUTemp.isChecked():
            x_values3, y_values3 = zip(*CPUTemperatureArray)
            self.axes.plot(mdates.num2date(x_values3), y_values3, label = "CPUTemperature")
        if self.checkBox_InternalTemp.isChecked():
            x_values2, y_values2 = zip(*internalTemperatureArray)
            self.axes.plot(mdates.num2date(x_values2), y_values2, label = "internalTemperature")
        if self.checkBox_ExternalTemp.isChecked():
            x_values, y_values = zip(*externalTemperatureArray)
            self.axes.plot(mdates.num2date(x_values), y_values, label = "externalTemperature")

        # Format x-axis as dates
        self.axes.xaxis_date()
        # Set labels and show the plot
        self.axes.set_xlabel('Time')
        self.axes.set_ylabel('Temperature')
        self.figure.autofmt_xdate()
        self.axes.legend() 
        self.axes.grid()

        cursor = Cursor(self.axes, horizOn=True, vertOn=True, useblit=True,
                color = 'r', linewidth = 1)
        # Creating an annotating box
        self.annot = self.axes.annotate("", xy=(0,0), xytext=(-40,40),textcoords="offset points",
                            bbox=dict(boxstyle='round4', fc='linen',ec='k',lw=1),
                            arrowprops=dict(arrowstyle='-|>'))
        self.annot.set_visible(False)
        self.canvas.mpl_connect("button_press_event", self.drawCursorTempPlot)
        self.canvas.draw()

    def drawCursorTempPlot(self, event):
        if not self.axes:
            return
        
        # global coord
        # coord.append((event.xdata, event.ydata))
        x = event.xdata
        y = event.ydata
        

        x_datetime = datetime.datetime.utcfromtimestamp(x)
        
        # printing the values of the selected point
        # print([x,y]) 
        self.annot.xy = (x,y)
        text = "({}, {:.2f})".format(x.strftime('%H:%M:%S'),y)
        self.annot.set_text(text)
        self.annot.set_visible(True)

        self.canvas.draw() #redraw the figure
        

    def clearPlotAltitude(self):
        altitudeArray.clear()
        self.axesAltitude.clear()
        self.canvasAltitude.draw()

    def startPlottingAltitude(self):
        self.plotting_Altitude_enabled = True

    def stopPlottingAltitude(self):
        self.plotting_Altitude_enabled = False

    def sliderValueChangedAltitude(self):
        global altitudeArray
        value = self.horizontalSliderAltitudePlot.value()
        self.horizontalSliderAltitudeLabel.setText(str(value))
         # Clear the plot if the slider value is reduced
        if value < len(altitudeArray):
            elements_to_remove = len(altitudeArray) - value
            altitudeArray = altitudeArray[elements_to_remove:]
        return value

    def creatAltitudeRealTimePlot(self):

        # Create a Matplotlib figure
        self.figureAltitude = Figure()

        # Create a Matplotlib canvas
        self.canvasAltitude = FigureCanvas(self.figureAltitude)
        self.axesAltitude = self.figureAltitude.add_subplot(111)

            # Format the X-axis labels as time
        self.axesAltitude.xaxis_date()
        self.axesAltitude.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))

        # Rotate the X-axis labels for better readability
        self.figureAltitude.autofmt_xdate()

        # self.lines = self.axes.plot([], [])[0]

        # Create a layout and add the Matplotlib canvas to it
        layout = QVBoxLayout(self.widgetAltitudePlot)
        layout.addWidget(self.canvasAltitude)
        layout.addWidget(NavigationToolbar2QT(self.canvasAltitude, self.widgetAltitudePlot))

        # Update the canvas
        self.canvasAltitude.draw()

        self.plotting_Altitude_enabled = True

    def renderAltitudePlot(self, data):
        if not self.plotting_Altitude_enabled:
            return
    
        # Assuming parse_packet is defined somewhere
        packet4Plot = parse_packet(data)

        # Update global_data_array with new data
        current_time = datetime.datetime.now()

        altitude = packet4Plot['altitude']

        # Apply Kalman filter
        self.kalman_filter_altitude.predict()
        self.kalman_filter_altitude.update(altitude)
         # Get the filtered temperature
        filtered_altitude_kalman = self.kalman_filter_altitude.x[0]

        self.ema_alpha12 = 0.5  # EMA smoothing factor
        self.ema_value = 0.0
        filtered_altitude_expmove_avr = self.ema_alpha12 * altitude + (1 - self.ema_alpha12) * self.ema_value
        
        self.ema_alpha13 = 1  # EMA smoothing factor 
        filtered_altitude_median = self.ema_alpha13 * altitude + (1 - self.ema_alpha13) * self.ema_value

        # Clear the existing plot
        self.axesAltitude.clear()

        # Get the limit from the slider
        limit = self.sliderValueChangedAltitude()

        selected_filter = self.comboBox_Filters_Altitude.currentText()

        if selected_filter is None:
            selected_filter = "No-Filter"

        # Plot the data from externalTemperatureArray
        if len(altitudeArray) < limit:
            x = mdates.date2num(current_time)
            y = 0
            if selected_filter == "No-Filter":
                y = altitude
            elif selected_filter == "Kalman":
                y = filtered_altitude_kalman
            elif selected_filter == "exp. mov_aver":
                y = filtered_altitude_expmove_avr
            elif selected_filter == "median":
                y = filtered_altitude_median
            altitudeArray.append((x, y))
        else:
            altitudeArray[0:limit-1 ] = altitudeArray[1:limit]
            if selected_filter == "No-Filter":
                altitudeArray[limit-1] = (mdates.date2num(current_time), altitude)
            elif selected_filter == "Kalman":
                altitudeArray[limit-1] = (mdates.date2num(current_time), filtered_altitude_kalman)
            elif selected_filter == "exp. mov_aver":
                altitudeArray[limit-1] = (mdates.date2num(current_time), filtered_altitude_expmove_avr)
            elif selected_filter == "median":
                altitudeArray[limit-1] = (mdates.date2num(current_time), filtered_altitude_median)
                
        if self.checkBox_Altitude.isChecked():
            x_values3, y_values3 = zip(*altitudeArray)
            self.axesAltitude.plot(mdates.num2date(x_values3), y_values3,)

        # Format x-axis as dates
        self.axesAltitude.xaxis_date()
        # Set labels and show the plot
        self.axesAltitude.set_xlabel('Time')
        self.axesAltitude.set_ylabel('Altitude')
        self.figure.autofmt_xdate()
        self.axesAltitude.grid()

        cursor = Cursor(self.axesAltitude, horizOn=True, vertOn=True, useblit=True,
                color = 'r', linewidth = 1)
        # Creating an annotating box
        self.annot1 = self.axesAltitude.annotate("", xy=(0,0), xytext=(-40,40),textcoords="offset points",
                            bbox=dict(boxstyle='round4', fc='linen',ec='k',lw=1),
                            arrowprops=dict(arrowstyle='-|>'))
        self.annot1.set_visible(False)
        self.canvasAltitude.mpl_connect("button_press_event", self.drawCursorAltitudePlot)
        self.canvasAltitude.draw()

    def drawCursorAltitudePlot(self, event):
        if not self.axes:
            return
        x = event.xdata
        y = event.ydata
        self.annot1.xy = (x,y)
        text = "({:.2g}, {:.2g})".format(x,y)
        self.annot1.set_text(text)
        self.annot1.set_visible(True)
        self.canvasAltitude.draw() #redraw the figure

    def render7display(self, data):
        packet4Plot = parse_packet(data)
        externalTemp = '{:.2f}'.format(packet4Plot['temp_external'] / 100)
        internalTemp = '{:.2f}'.format(packet4Plot['temp_hdc'] / 100)
        CPUTemp = '{:.2f}'.format(packet4Plot['temp_mc'] / 100)
        altitude = packet4Plot['altitude']
        self.lcdNumberTempCPU.display(CPUTemp)
        self.lcdNumberExtrenalTemp.display(externalTemp)
        self.lcdNumberInternalTemp.display(internalTemp)
        self.lcdNumberAltitude.display(altitude)

    def connect_to_serial_port(self):
        self.disconnect_from_serial_port()
        selected_port = self.comboBox_ComPorts.currentData()
        if selected_port is not None:
            selected_port_name = str(selected_port).split(' ')[0]
        else:
            print("No port selected or data is None")
            return

        
        selected_baud_rate = int(self.comboBoxBaudRate.currentText())
        data_bits = self.get_data_bits()
        parity = self.get_parity()
        stop_bits = self.get_stop_bits()

        try:
            self.serial_connection = serial.Serial(
                port= selected_port_name,
                baudrate=selected_baud_rate,
                bytesize=data_bits,
                parity=parity,
                stopbits=stop_bits,
                timeout=None,
            )

            self.serial_connection.rs485_mode = serial.rs485.RS485Settings()

            print(self.serial_connection)
            print(f"Connected to {selected_port_name}...")

            # Create and start the serial reading thread
            self.serial_thread = SerialReadThread(self.serial_connection)
            self.serial_thread.received_data.connect(self.update_text_browser)
            
            # Create dataBase
            self.dataBase = DataBase

            self.serial_thread.received_data.connect(self.dataBase.insert_data)
            
            self.serial_thread.received_data.connect(self.renderPlot)
            self.serial_thread.received_data.connect(self.render7display)

            self.serial_thread.received_data.connect(self.renderAltitudePlot)
            
            self.serial_thread.received_data.connect(self.updateMap)

            self.serial_thread.start()

            print("connect to serial port")

        except serial.SerialException as e:
            print(f"Failed to connect to {selected_port_name}: {e}")
    
    def update_text_browser(self, data):
        print("update text brauzer")

        if self.radioButton_ASCII.isChecked():
            try:
                # Attempt to decode as ASCII and handle exceptions if data is not valid ASCII
                decoded_data = data.decode('ascii')
                self.textBrowserComPort.append(decoded_data)
            except UnicodeDecodeError:
                # If data is not valid ASCII, display a placeholder message or handle it differently
                self.textBrowserComPort.append("<Non-ASCII data received>")
        elif self.radioButton_HEX.isChecked():
            if self.radioButton_PARSED.isChecked():
                # Parse the packet data and print or update GUI
                try:
                    spurtnik_data = parse_packet(data)
                    print(spurtnik_data)
                    # Update the GUI here if necessary
                    self.textBrowserComPort.append(str(spurtnik_data))
                except Exception as e:
                    print("Error parsing packet:", e)
                    # Handle errors, possibly update GUI with error message
                    self.textBrowserComPort.append("Error parsing packet:")
            else:
                # Convert bytes to hex representation
                hex_data = data.hex()
                self.textBrowserComPort.append(hex_data)


    def clear_text_browser(self):
        self.textBrowserComPort.clear()
        print("Text browser cleared.")

    def creatTempDBPlot(self):
        conn = sqlite3.connect('my_database.db')
        cursor = conn.cursor()
        # Fetch data from the database
        query = "SELECT temp_hdc, temp_mc, temp_external, system_time FROM data"
        
        try:
            cursor.execute(query)
            rows = cursor.fetchall()
        except sqlite3.Error as e:
            # Handle the exception, you can print the error message or log it
            conn.close()
            return f"Error fetching data: {str(e)}"
        
        # Separate data for plotting
        temps_hdc = [row[0] for row in rows]
        temps_mc = [row[1] for row in rows]
        temps_external = [row[2] for row in rows]

        # Extract datetime objects from the system_time column
        time_points = [datetime.datetime.strptime(row[3], "%Y-%m-%d %H:%M:%S") for row in rows]

        conn.close()

        # Create a Matplotlib figure
        self.figureTempDB = Figure()

        # Create a Matplotlib canvas
        self.canvasTempDB = FigureCanvas(self.figureTempDB)
        self.axesTempDB = self.figureTempDB.add_subplot(111)


        if self.dbCPUtemp.isChecked():
            self.axesTempDB.plot(time_points, temps_hdc, label='temp_hdc')
        if self.dbExternaltemp.isChecked():
            self.axesTempDB.plot(time_points, temps_mc, label='temp_mc')
        if self.dbInternaltemp.isChecked():
            self.axesTempDB.plot(time_points, temps_external, label='temp_external')

        self.axesTempDB.xaxis_date()
       
        self.axesTempDB.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M:%S'))

        self.figureTempDB.autofmt_xdate()

        self.axesTempDB.set_xlabel('Time')
        self.axesTempDB.set_ylabel('Temperature')
        self.axesTempDB.set_title('Temperature Data Over Time')
        self.axesTempDB.legend()

        layout = QVBoxLayout(self.DBTempPLot)
        layout.addWidget(NavigationToolbar2QT(self.canvasTempDB, self.DBTempPLot))
        layout.addWidget(self.canvasTempDB)

        self.canvasTempDB.draw()

    def updateDbPlot(self):
        
        self.axesTempDB.clear()

        datefromDB = self.dateEditDBFfrom.date()
        qdatetimefrom = QDateTime(datefromDB, QTime(0, 0, 0), Qt.TimeSpec.UTC)
        formatted_date_time_from = qdatetimefrom.toString("yyyy-MM-dd HH:mm:ss")
        
        dateToDB = self.dateEditDBFto.date()
        qDateTimeTo = QDateTime(dateToDB, QTime(0, 0, 0), Qt.TimeSpec.UTC)
        formatted_date_time_to = qDateTimeTo.toString("yyyy-MM-dd HH:mm:ss")

        conn = sqlite3.connect('my_database.db')
        cursor = conn.cursor()
        # Fetch data from the database
        query = "SELECT temp_hdc, temp_mc, temp_external, system_time FROM data WHERE system_time >= '" + formatted_date_time_from + "' and system_time <= '" + formatted_date_time_to + "' order by system_time asc"
        

        # print(query)
        
        try:
            cursor.execute(query)
            rows = cursor.fetchall()
            try:
                print(rows[0])
            except IndexError as e:
                print("Error:", e)

        except sqlite3.Error as e:
            # Handle the exception, you can print the error message or log it
            print(str(e))
            conn.close()
            return f"Error fetching data: {str(e)}"
        
        # Separate data for plotting
        temps_hdc = [row[0] for row in rows]
        temps_mc = [row[1] for row in rows]
        temps_external = [row[2] for row in rows]

        # Extract datetime objects from the system_time column
        time_points = [datetime.datetime.strptime(row[3], "%Y-%m-%d %H:%M:%S") for row in rows]

        conn.close()

        # Clear the existing plot
        self.axesTempDB.clear()

        if self.dbCPUtemp.isChecked():
            self.axesTempDB.plot(time_points, temps_hdc, label='temp_hdc')
        if self.dbExternaltemp.isChecked():
            self.axesTempDB.plot(time_points, temps_mc, label='temp_mc')
        if self.dbInternaltemp.isChecked():
            self.axesTempDB.plot(time_points, temps_external, label='temp_external')

        self.axesTempDB.set_xlabel('Time')
        self.axesTempDB.set_ylabel('Temperature')
        self.axesTempDB.set_title('Temperature Data Over Time')
        self.axesTempDB.legend()
        self.axesTempDB.xaxis_date()
        self.axesTempDB.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d %H:%M:%S'))
        self.figureTempDB.autofmt_xdate()
        self.canvasTempDB.draw()
            
    def updateMap(self, data):
        packet = parse_packet(data)
        altitude = packet['altitude'] + 10 + (np.random.rand() - 0.5) * 0.01
        latitude = packet['latitude'] + 43.270141887866416 + (np.random.rand() - 0.5) * 0.01
        longitude = packet['longitude'] + 76.93517262044855 + (np.random.rand() - 0.5) * 0.01
                
        
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Update the dataframe with the new data
        new_data = {
            'timestamp': timestamp,
            'latitude': latitude,
            'longitude': longitude,
            'altitude': altitude
        }

        self.dataframe = self.dataframe.append(new_data, ignore_index=True)
        
        # Create a new folium map
        new_map = folium.Map(location=self.start_location, zoom_start=13)
        
        # Add GPS points to the map
        for _, row in self.dataframe.iterrows():
            folium.Marker(
                location=[row['latitude'], row['longitude']],
                popup=f"Time: {row['timestamp']}<br>Coordinates: ({row['latitude']}, {row['longitude']})<br>Altitude: {row['altitude']} meters",
                icon=folium.Icon(color='blue', icon='info-sign')
            ).add_to(new_map)
        
        # Add lines connecting the points (tracks)
        folium.PolyLine(
            locations=[(row['latitude'], row['longitude']) for _, row in self.dataframe.iterrows()],
            color='blue',
            weight=2.5,
            opacity=1
        ).add_to(new_map)
        
        # Save the new map to a BytesIO object
        self.map_data = io.BytesIO()
        new_map.save(self.map_data, close_file=False)
        
        # Update the QWebEngineView
        webView = self.widgetMap.findChild(QWebEngineView)
        webView.setHtml(self.map_data.getvalue().decode())


    
    def drawMap(self):
        # Create a map without any data
        self.map = folium.Map(location=[43.238949, 76.889709])

        # Add Mouse Position to get the coordinate (Lat, Long) for a mouse over on the map
        formatter = "function(num) {return L.Util.formatNum(num, 5);};"
        mouse_position = MousePosition(
            position='topright',
            separator=' Long: ',
            empty_string='NaN',
            lng_first=False,
            num_digits=20,
            prefix='Lat:',
            lat_formatter=formatter,
            lng_formatter=formatter,
        )

        self.map.add_child(mouse_position)

        self.dataframe = pd.DataFrame(columns=['timestamp', 'latitude', 'longitude', 'altitude'])
        self.start_location = [43.238949, 76.889709]  # Initial center of the map

        # Save map data to data object
        self.map_data = io.BytesIO()
        self.map.save( self.map_data, close_file=False)

        # Set HTML content to QWebEngineView
        webView = QWebEngineView(self.widgetMap)
        webView.setHtml(self.map_data.getvalue().decode())

        # Add the webView to the layout
        layout = QVBoxLayout(self.widgetMap)
        layout.addWidget(webView)
        self.widgetMap.setLayout(layout)

        # Initialize list to store markers
        self.markers = []

class GPSData(QObject):
    new_data = pyqtSignal(dict)

    def __init__(self):
        super().__init__()
        self.gps_data = []

    def add_data(self, data):
        self.gps_data.append(data)
        self.new_data.emit(data)

gps_data = GPSData()


class DataBase:
    def createDataBase():
        conn = sqlite3.connect('my_database.db')
        create_table_query = '''
        CREATE TABLE IF NOT EXISTS data (
            node TEXT,
            flag TEXT,
            length INTEGER,
            time_start TEXT,
            time TEXT,
            navi_start TEXT,
            latitude REAL,
            longitude REAL,
            altitude REAL,
            speed REAL,
            direction REAL,
            temp_start TEXT,
            temp_mc REAL,
            temp_hdc REAL,
            temp_external REAL,
            crc TEXT,
            rssi INTEGER,
            system_time TEXT  -- Add a new column for system time
        )
        '''
        conn.execute(create_table_query)
        conn.close()

    def insert_data(data):
        packet = parse_packet(data)
        conn = sqlite3.connect('my_database.db')

        # Get current system time
        current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        insert_query = '''
        INSERT INTO data (
            node, flag, length, time_start, time, navi_start, latitude, longitude, altitude,
            speed, direction, temp_start, temp_mc, temp_hdc, temp_external, crc, rssi, system_time
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        '''
        conn.execute(insert_query, (
            packet['node'], packet['flag'], packet['length'], packet['time_start'], packet['time'],
            packet['navi_start'], packet['latitude'], packet['longitude'], packet['altitude'],
            packet['speed'], packet['direction'], packet['temp_start'], packet['temp_mc'],
            packet['temp_hdc'], packet['temp_external'], packet['crc'], packet['rssi'], current_time
        ))
        conn.commit()
        conn.close()

        
def parse_packet(data):
        expected_length = 33
        print("data len = ")
        print(len(data))

        if len(data) != expected_length:
            print("Некорректная длина данных.")
            return None
        
        # Распаковка данных в соответствии со структурой пакета
        # > - big endian, B - unsigned char, f - float, H - unsigned short
        struct_format = '<B B B B I B f f H H H B h h h H b'
        unpacked_data = struct.unpack(struct_format, data)

        packet = {
            'node': unpacked_data[0],
            'flag': unpacked_data[1],
            'length': unpacked_data[2],
            'time_start': unpacked_data[3],
            'time': unpacked_data[4],  # Дополнительная обработка, если необходимо
            'navi_start': unpacked_data[5],
            'latitude': unpacked_data[6],
            'longitude': unpacked_data[7],
            'altitude': unpacked_data[8],
            'speed': unpacked_data[9],
            'direction': unpacked_data[10],
            'temp_start': unpacked_data[11],
            'temp_mc': unpacked_data[12],
            'temp_hdc': unpacked_data[13],
            'temp_external': unpacked_data[14],
            'crc': unpacked_data[15],
            'rssi': unpacked_data[16]
        }
        return packet


class SerialReadThread(QThread):
    # Change the signal to emit bytes instead of str
    received_data = pyqtSignal(bytes)

    def __init__(self, serial_connection):
        super().__init__()
        self.serial_connection = serial_connection


   
    def run(self):
        # Ensure the serial connection is properly opened
        if not self.serial_connection.is_open:
            print("Serial connection is not open.")
            return
        

        self.serial_connection.rs485_mode = serial.rs485.RS485Settings()
            # Flush input buffer
        self.serial_connection.reset_input_buffer()

        print("Entering the reading loop...")

        while True:
                if self.serial_connection.in_waiting > 0:
                # Check if data is available to read
                    try:
                        # Read the data
                        line = self.serial_connection.read(33)
                        print(f"Read data: {line}")  # Debug: Print the data read
                        
                        if(len(line) != 0 ):
                            # Emit the received data
                            self.received_data.emit(line)  # Emitting bytes
                    except Exception as e:
                        print(f"Error reading data: {e}")
        print("Exiting the reading loop...")


externalTemperatureArray = []
internalTemperatureArray = []
CPUTemperatureArray = []
altitudeArray = []

class OpenGLWidget_IMU(QOpenGLWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(640, 480)
        self.ax1 = self.ay1 = self.az1 = 0.0
        self.yaw_mode = False

    def initializeGL(self):
        # self.initializeOpenGLFunctions()  # Initialize OpenGL functions
        glShadeModel(GL_SMOOTH)
        glClearColor(0.0, 0.0, 0.0, 0.0)
        glClearDepth(1.0)
        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)
        glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST)

    def resizeGL(self, w, h):
        if h == 0:
            h = 1
        glViewport(0, 0, w, h)
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        gluPerspective(45, w / h, 0.1, 100.0)
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()

    def paintGL(self):
        self.draw()
        self.draw_overlay_text()


    def draw(self):
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        glLoadIdentity()
        glTranslatef(0.0, 0.0, -7.0)

        osd_text = f"pitch: {self.ay1:.2f}, roll: {self.ax1:.2f}"
        if self.yaw_mode:
            osd_text += f", yaw: {self.az1:.2f}"

        self.drawText((-2, -2, 2), osd_text)

        if self.yaw_mode:
            glRotatef(self.az1, 0.0, 1.0, 0.0)
        glRotatef(self.ay1, 1.0, 0.0, 0.0)
        glRotatef(-self.ax1, 0.0, 0.0, 1.0)

        glBegin(GL_QUADS)
        self.draw_cube()
        glEnd()

    def drawText(self, position, textString):
        # This method needs to be updated to render text within a QOpenGLWidget
        # In PyQt6, you might use QLabel instead of trying to render using OpenGL directly
        pass
    

    def draw_overlay_text(self):
        # Save OpenGL state
        glPushAttrib(GL_ALL_ATTRIB_BITS)
        glPushMatrix()

        # Use QPainter to draw text on top of the OpenGL scene
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        painter.setPen(QColor(255, 255, 255))
        painter.setFont(QFont('Arial', 14))

        osd_text = f"Pitch: {self.ay1:.2f}, Roll: {self.ax1:.2f}"
        if self.yaw_mode:
            osd_text += f", Yaw: {self.az1:.2f}"

        # Draw the text at the top left corner of the window
        painter.drawText(10, 30, osd_text)
        painter.end()

        # Restore OpenGL state
        glPopMatrix()
        glPopAttrib()


    def draw_cube(self):
        vertices = [
            [1.0, 0.9, -1.0], [-1.0, 0.9, -1.0], [-1.0, 0.9, 1.0], [1.0, 0.9, 1.0],
            [1.0, -0.9, 1.0], [-1.0, -0.9, 1.0], [-1.0, -0.9, -1.0], [1.0, -0.9, -1.0]
        ]
        colors = [
            [0.0, 1.0, 0.0], [1.0, 0.5, 0.0], [1.0, 0.0, 0.0],
            [1.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 1.0]
        ]
        indices = [(0, 1, 2, 3), (4, 5, 6, 7), (0, 3, 4, 7), (1, 2, 5, 6), (0, 1, 6, 7), (2, 3, 4, 5)]
        for face, color in zip(indices, colors):
            glColor3fv(color)
            for vertex in face:
                glVertex3fv(vertices[vertex])

    def update_data(self, roll, pitch, yaw):
        self.ax1 = roll
        self.ay1 = pitch
        self.az1 = yaw
        self.update()

class KalmanFilter2:
    def __init__(self, dt, process_noise, measurement_noise):
        self.dt = dt
        self.process_noise = process_noise
        self.measurement_noise = measurement_noise
        self.x = np.zeros((2, 1))
        self.P = np.eye(2)
        self.F = np.array([[1, -dt], [0, 1]])
        self.B = np.array([[dt], [0]])
        self.H = np.array([[1, 0]])
        self.Q = process_noise * np.eye(2)
        self.R = np.array([[measurement_noise]])

    def predict(self, u):
        self.x = np.dot(self.F, self.x) + np.dot(self.B, u)
        self.P = np.dot(np.dot(self.F, self.P), self.F.T) + self.Q

    def update(self, z):
        S = np.dot(np.dot(self.H, self.P), self.H.T) + self.R
        K = np.dot(np.dot(self.P, self.H.T), np.linalg.inv(S))
        y = z - np.dot(self.H, self.x)
        self.x += np.dot(K, y)
        I = np.eye(self.P.shape[0])
        self.P = (I - np.dot(K, self.H)) @ self.P

    def get_angle(self):
        return self.x[0, 0]

def parse_sensor_data(data):
    try:
        parts = data.split(',')
        if len(parts) != 8:
            return None
        sensor_type_1 = parts[0].strip()
        ax, ay, az = map(float, parts[1:4])
        sensor_type_2 = parts[4].strip()
        gx, gy, gz = map(float, parts[5:8])
        if sensor_type_1 == "Acceleration" and sensor_type_2 == "Gyroscope":
            return {"Acceleration": [ax, ay, az], "Gyroscope": [gx, gy, gz]}
    except ValueError:
        return None
    return None



if __name__ == "__main__":
    os.environ["QSG_RHI_BACKEND"] = "opengl"
 
    QCoreApplication.setAttribute(Qt.ApplicationAttribute.AA_UseOpenGLES)
   # Set the OpenGL format before creating the application
    # Force Qt to use OpenGL as the backend for rendering
        
    # Set the OpenGL format before creating the application
    format = QSurfaceFormat()
    format.setVersion(2, 1)  # Set a lower version like 2.1 if 3.3 is problematic
    format.setProfile(QSurfaceFormat.OpenGLContextProfile.CompatibilityProfile)  # Use CompatibilityProfile instead of CoreProfile
    format.setDepthBufferSize(24)  # Optional: set depth buffer size
    format.setStencilBufferSize(8)  # Optional: set stencil buffer size
    QSurfaceFormat.setDefaultFormat(format)


    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    DataBase.createDataBase()
    MainWindow.show()
    sys.exit(app.exec())
